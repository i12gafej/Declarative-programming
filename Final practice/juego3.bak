(define (crear-mazo)
  (append
   (map (lambda (valor) (list valor 'corazones))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))
   (map (lambda (valor) (list valor 'corazones))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))
   (map (lambda (valor) (list valor 'corazones))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))
   (map (lambda (valor) (list valor 'corazones))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))
   (map (lambda (valor) (list valor 'diamantes))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))
   (map (lambda (valor) (list valor 'diamantes))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))
   (map (lambda (valor) (list valor 'diamantes))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))
   (map (lambda (valor) (list valor 'diamantes))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))
   (map (lambda (valor) (list valor 'tréboles))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))
   (map (lambda (valor) (list valor 'tréboles))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))
   (map (lambda (valor) (list valor 'tréboles))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))
   (map (lambda (valor) (list valor 'tréboles))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))
   (map (lambda (valor) (list valor 'picas))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))
   (map (lambda (valor) (list valor 'picas))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))
   (map (lambda (valor) (list valor 'picas))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))
   (map (lambda (valor) (list valor 'picas))
               (list 'A '2 '3 '4 '5 '6 '7 '8 '9 '10 'J 'Q 'K))))

;; Función para generar una lista de números desde 0 hasta n-1
(define (range n)
  (if (= n 0)
      '()
      (cons (- n 1) (range (- n 1)))))

;; Función para intercambiar dos elementos en una lista en las posiciones i y j
(define (swap lst i j)
  (let ((elem-i (list-ref lst i))
        (elem-j (list-ref lst j)))
    (map (lambda (idx)
           (cond ((= idx i) elem-j)
                 ((= idx j) elem-i)
                 (else (list-ref lst idx))))
         (range (length lst)))))

;; Función recursiva para barajar la lista
(define (barajar mazo)
  (define (shuffle-helper lst n)
    (if (<= n 0)
        lst
        (let ((j (random (+ n 1))))
          (shuffle-helper (swap lst n j) (- n 1)))))
  (shuffle-helper mazo (- (length mazo) 1)))


;; Devuelve los nuevos mano y mazo
(define (add-carta-mano mano mazo)
  (cons (append mano (list (car mazo))) (cdr mazo))
  )

(define (extraer-mazo mazo)
  (cdr mazo)
  )

;; Obtener carta

;; Definir la función count
(define (count pred lst)
  (define (count-helper lst acc)
    (cond
      ((null? lst) acc)                               ; Si la lista está vacía, devuelve el acumulador
      ((pred (car lst)) (count-helper (cdr lst) (+ acc 1)))  ; Si el predicado es verdadero, incrementa el acumulador
      (else (count-helper (cdr lst) acc))))           ; Si no, sigue sin incrementar
  (count-helper lst 0))                               ; Inicializa el acumulador en 0

;; Calcular el valor de una carta en Blackjack
(define (valor-carta carta)
  (let ((valor (car carta)))
    (cond
      ((equal? valor 'A) 11)
      ((member valor '(J Q K)) 10)
      (else (string->number (number->string valor))))))

;; Calcular el valor total de una mano en Blackjack, considerando ases
(define (valor-mano mano)
  (let ((suma (apply + (map valor-carta mano)))
        (ases (count (lambda (carta) (equal? (car carta) 'A)) mano)))
    (let loop ((suma suma) (ases ases))
      (if (and (> suma 21) (> ases 0))
          (loop (- suma 10) (- ases 1))
          suma))))

;; Mostrar el estado del jugador y el crupier
(define (mostrar-estado jugador crupier apuesta)
  (displayln (string-append "Apuesta: " (number->string apuesta)))
  (displayln (string-append "Jugador: " (number->string (valor-mano jugador)) " - " (format "~a" jugador)))
  (displayln (string-append "Crupier: " (number->string (valor-mano crupier)) " - " (format "~a" crupier))))


(define (mostrar-jugador jugador mano)
  (cond
    ((eq? jugador 'crupier) (printf "Crupier: ~a (~a)\n" mano (valor-mano mano)
                                    ) mano)
    ((eq? jugador 'jugador) (printf "Jugador: ~a (~a)\n" mano (valor-mano mano)
                                    ) mano)
    )
  )


(define mazo (barajar (crear-mazo)))

(define (apostar-fichas fichas-disponibles)
  (let loop ()
    (displayln "¿Cuantas fichas quieres apostar? (20, 50, 100, 200, 500, 1000): ")
    (let 
        ((fichas (string->number (read-line))))    
      (cond
        ;; el número de fichas es correcto
        ((and (or
          (= 20 fichas)
          (= 50 fichas)
          (= 100 fichas)
          (= 200 fichas)
          (= 500 fichas)
          (= 1000 fichas)
          ) (<= fichas fichas-disponibles)) fichas)
        (else (display "Fichas insuficientes o erroneas\n") (loop))
     )
    ))
  )

(define (cantidad-fichas!)
  (let loop ()
    (displayln "¿Con cuantas fichas quieres jugar?")
    (let
        (
         (fichas (string->number (read-line))))    
      (cond
        ;; el número de fichas es correcto
        ((and
          (real? fichas)
          (> fichas 0)
          ) fichas)
        (else (display "Fichas erroneas\n") (loop))
     )
    ))
  )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Tipo de dato JUGADA

(define (crear-jugada mano fichas-disponibles apuesta)
  (list
     (list 'mano mano)
     (list 'fichas-disponibles fichas-disponibles)
     (list 'apuesta apuesta)
   )
  )
(define (mano jugada)
  (cadr (assoc 'mano jugada))
  )
(define (fichas-disponibles jugada)
  (cadr (assoc 'fichas-disponibles jugada))
  )
(define (apuesta jugada)
  (cadr (assoc 'apuesta jugada))
  )

(define (cambiar-mano! jugada nuevo)
  (set-cdr! (assoc 'mano jugada) (list nuevo))
  )

(define (cambiar-fichas-disponibles! jugada nuevo)
  (set-cdr! (assoc 'fichas-disponibles jugada) (list nuevo))
  )

(define (cambiar-apuesta! jugada nuevo)
  (set-cdr! (assoc 'apuesta jugada) (list nuevo))
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Se envia la apuesta, las fichas que tiene, y la mano
; Si el valor de la mano es superior o igual a 21, devuelve la mano, (- apuesta fichas-disponibles) apuesta
; Si se elige pedir, se relanza el let con la nueva mano
; Si se elige plantarse, se devuelve el objeto mano, (- apuesta fichas-disponibles) y apuesta
; Si se elige doblar y no hay suficientes fichas, se vuelve a preguntar
; Si se elige doblar, se devuelve el objeto (append mano (list (sacar-carta mazo)), (- (* 2 apuesta) fichas-disponibles) (* 2 apuesta)

(define (turno-jugador mano-mazo fichas-disponibles apuesta pidio?)
  (let
    (
     (valor-mano (valor-mano (car mano-mazo)))
     (mazo (cdr mano-mazo))
     (fichas-disponibles fichas-disponibles)
     (apuesta apuesta))
     (printf "Jugador: ~a (~a)\n" mano (valor-mano mano))
     (cond
       ; La mano ya supera o iguala el valor de 21
       ((>= valor-mano 21)
        (cons (crear-jugada mano (- fichas-disponibles apuesta) apuesta)
              mazo))
       (else
        (display "Qué prefieres?\n 1. Pedir\n 2. Plantarte\n 3. Doblar\n")
        (let
         (
          (eleccion (string->symbol (read-line)))
          )
          (cond
            ; Pedir carta
            ((eq? eleccion '1)
             (display "Pide carta.\n")
             (turno-jugador (add-carta-mano mano mazo) fichas-disponibles apuesta #t))
            ; Plantarse
            ((eq? eleccion '2)
             (display "Se planta.\n")
             (cons (crear-jugada mano (- fichas-disponibles apuesta) apuesta) mazo))
            ; Doblar 
            ((and (eq? eleccion '3))
             (cond
               ; Si ya pidió, no puede doblar
               (pidio?
                 (display "No puedes doblar una vez pides.\n")
                 (turno-jugador (add-carta-mano mano mazo) fichas-disponibles apuesta #t))
               ; Hay suficientes fichas
               ((>= fichas-disponibles (* 2 apuesta))
                  (printf "Doblar la apuesta ~a * 2 = ~a" apuesta (* 2 apuesta))
                  (cons (crear-jugada mano (- fichas-disponibles (* 2 apuesta)) (* 2 apuesta))
                        mazo)
                  )
               ; No hay suficientes fichas
               (else
                (display "No hay suficientes fichas para doblar.\n")
                (turno-jugador (add-carta-mano mano mazo) fichas-disponibles apuesta #t))
                ))
             )
            )
        ))
       ))
  )
;(cantidad-fichas!)

(define (ronda fichas fichas-apostar)
  (let
      (
       
       )
    
      )
)

; Hacer rondas hasta que fichas 
(define (blackjack-fichas)
  (let*
      (
       (fichas (cantidad-fichas!))
       )
  (do
      (
       (ronda (ronda fichas fichas-apostar))
       )
      ))
  )