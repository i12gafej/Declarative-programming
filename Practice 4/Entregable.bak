;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 1.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|
Nombre:
   modulo-vector
Objetivo:
   Calcula el módulo de un vectos
Parámetros:
 - v: vector
Resultado:
   Numérico.
Descripción de la solucion:
   Dado un vector, te devuelve el módulo calculado como:
   |v| = (sqrt x1^2 + x2^2 + x3^2 .... + xn^2)
Funciones auxiliares a las que llama:
   ninguno
|#

(define (modulo-vector v)
  (do
      ;; Variables iterativas
      (
       (i 1 (+ i 1))
       (resultado (sqr (vector-ref v 0)) (+ (sqr (vector-ref v i)) resultado))
       )
      ;; Condición de parada
      ((= i (vector-length v)) (sqrt resultado))
   )
)

;(modulo-vector #(4 4 4 4))
;(modulo-vector #(3 4))
;(modulo-vector #(3 3 3 3))

#|
Resultados
8
5
6
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 2.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|
Nombre:
   media-aritmetica
Objetivo:
   Calcula la media aritmetica de un vectos
Parámetros:
 - v: vector
Resultado:
   Numérico.
Descripción de la solucion:
   Dado un vector, te devuelve la media aritmética:
   |v| = (x1 + x2 + x3 .... + xn)/n
Funciones auxiliares a las que llama:
   ninguno
|#

(define (media-aritmetica v)
  (do
      ;; Variables iterativas
      (
       (i 1 (+ i 1))
       (resultado (vector-ref v 0) (+ (vector-ref v i) resultado 0.))
       )
      ;; Condición de parada
      ((= i (vector-length v)) (/ resultado (vector-length v)))
   )
)

;(media-aritmetica #(2 2 3 1 2 4 0 6 -2))
;(media-aritmetica #(1 2 3 4 5 6 7 8 9))
;(media-aritmetica #(0 2 4 6 8 10 12 14 16 18 20))

#|
Resultados:
2.0
5.0
10.0
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 3.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|
Nombre:
   extraer-columna
Objetivo:
   Dada una matriz de dos dimensiones, extrae la columna indicada
Parámetros:
 - m: matriz
 - col: columna a extraer
Resultado:
   Vector de la columna.
Descripción de la solucion:
   Dada una matriz
    1. 2. 3. 2.
    4. 5. 6. 4.
    7. 8. 9. 7.
   la columna 1 sería la siguiente: (2. 5. 8.)
Funciones auxiliares a las que llama:
   ninguno
|#


(define (extraer-columna m col) 
   ;; Cuerpo Let * 
  (cond
    ;; Es un vector
   ((not (vector? m)) "No es un vector")
   ;; Comprobar que es un vector de vectores
   (
    (do
        (
         (tam (vector-length m))
         (i 1 (+ i 1))
         (actual (vector-ref m 0) (vector-ref m i))
        )
      ((or (not (vector? actual)) (= i tam)) (not (vector? actual)))
      )
    "No es un vector de vectores")
   ;; Comprobar que todas las filas sean iguales de tamaño
   (
    (do
        (
         (tam (vector-length m))
         (i 2 (+ i 1))
         (actual (vector-length (vector-ref m 0)) siguiente)
         (siguiente (vector-length (vector-ref m 1)) (vector-length (vector-ref m i)))
        )
      ((or (not (= actual siguiente)) (= i tam)) (not (= actual siguiente)))
      )
    "Filas desiguales")
   ;; Comprobar si la columna está en el rango posible
   ((< (- (vector-length (vector-ref m 0)) 1) col) "Fuera de rango")
   ;; Si todo lo demás está correcto
   (else
    (let*
   ;; Variables let * 
   (
    (fil-size (vector-length m))
    (col-size (vector-length (vector-ref m 0)))
    (resultado (make-vector fil-size))
    )
    (do
     ;; Variables iterativas
     (
      ;; Incrementa cuando se llega al final de la fila
      (i 0 (if (= (+ j 1) col-size) (+ i 1) i))
      ;; Incrementa mientras que no llegue al final de la fila
      ;; , si no se pone a 0 y sigue
      (j 0 (if (= (modulo (+ j 1) col-size) 0) 0 (+ j 1)))
     )
     ;; Condición parada
     ((and (= i fil-size)) resultado)
      ;; Cuerpo do
       (if (= j col)
         (vector-set! resultado i (vector-ref (vector-ref m i) j))
         #f
        )
    )))))

;(extraer-columna #(#(1. 2. 3. 2.) #(4. 5. 6. 4.) #(7. 8. 9. 7.)) 0)
;(extraer-columna #(#(1. 2. 3. 2.) #(4. 5. 6. 4.) #(7. 8. 9. 7.)) 4)
;(extraer-columna #(#(1. 2. 3. 2.) #(4. 5. 6. 4. 8.) #(7. 8. 9. 7.)) 0)
;(extraer-columna #("cadema" "Cadena" #(7. 8. 9. 7.)) 0)
;(extraer-columna 'matriz 0)

#|
Resultado:
#(1.0 4.0 7.0)
"Fuera de rango"
"Filas desiguales"
"No es un vector de vectores"
"No es un vector"
|#


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 4.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|
Nombre:
   maxiMin
Objetivo:
   Dada una matriz de dos dimensiones, devuelva el máximo de
   los valores mínimos de las columnas de la matriz
Parámetros:
 - m: matriz
Resultado:
   Numérico.
Descripción de la solucion:
   Dada una matriz
    1. 2. 3. 2.
    4. 5. 6. 4.
    7. 8. 9. 7.
   los valores mínimos de cada matriz son: 1 2 3 2,
   El valor máximo de estos mínimos es 3.
Funciones auxiliares a las que llama:
   extraer-columna, minimo
|#
(define (minimo v)  
   (let
       ;; Variables locales
       ((minimo (vector-ref v 0))
        (tam (vector-length v))
        )
     ;; Cuerpo del let
    (do
       ;; Variables iterativas
       (
         (j 1 (+ j 1))
       )
      ;; Condición de parada
      ((= tam j) minimo)
      ;; Cuerpo del DO
      (if (> minimo (vector-ref v j))
          (set! minimo (vector-ref v j))
          0)
      )
   )
 )

(define (maxiMin m)
  (cond
    ;; m no es un vector
    ((not (vector? m)) "No es un vector")
    ;; m no es un vector de vectores
    (
    (do
        (
         (tam (vector-length m))
         (i 1 (+ i 1))
         (actual (vector-ref m 0) (vector-ref m i))
        )
      ((or (not (vector? actual)) (= i tam)) (not (vector? actual)))
      )
    "No es un vector de vectores")
    ;; Comprobar que todas las filas sean iguales de tamaño
   (
    (do
        (
         (tam (vector-length m))
         (i 2 (+ i 1))
         (actual (vector-length (vector-ref m 0)) siguiente)
         (siguiente (vector-length (vector-ref m 1)) (vector-length (vector-ref m i)))
        )
      ((or (not (= actual siguiente)) (= i tam)) (not (= actual siguiente)))
      )
    "Filas desiguales")
   ;; Todo está bien
   (else
     (let*
      ;; Variables secuenciales locales
      (
       (fil-size (vector-length m))
       (col-size (vector-length (vector-ref m 0)))
       (resultado (make-vector col-size))
       (valor (minimo (extraer-columna m 0)))
       )
       ;; Cuerpo  del Let*
       (do
           (
            (i 2 (+ i 1))
            
            ;; Valor minimo de la columna siguiente
            (actual
                (minimo (extraer-columna m 1))
                (minimo (extraer-columna m i)))
            )
            ;; Condición de parada
            ((= i col-size) valor)
            ;; Cuerpo del DO
            
            (if (< valor actual)
                (set! valor actual)
                0
                )
        )
      )
    )
  )  
 )

;(maxiMin #(#(1. 2. 3. 2.) #(4. 5. 6. 4.) #(7. 8. 9. 7.)))
;(maxiMin #(#(1. 2. 3. 2.) #(4. 5. 6. 4. 7.) #(7. 8. 9. 7.)))
;(maxiMin #("cadena" #(4. 5. 6. 4.) #(7. 8. 9. 7.)))
;(maxiMin '(#(1. 2. 3. 2.) #(4. 5. 6. 4.) #(7. 8. 9. 7.)))

#|
Resultado:
3.0
"Filas desiguales"
"No es un vector de vectores"
"No es un vector"
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 5. a.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|
Nombre:
   determinante
Objetivo:
   Dada una matriz cuadrada 3x3 calcula el determinante
Parámetros:
 - m: matriz
Resultado:
   Numérico.
Descripción de la solucion:
   Dada una matriz
    
    x1 y1 z1 
    x2 y2 z2     = x1y2z3 + x2y3z1 + x3y1z2 - x1y3z2 - x2y1z3 - x3y2z1 
    x3 y3 z3

Funciones auxiliares a las que llama:
   extraer-columna
|#

;; x = 0, 1, 2
;; y = 1, 2, 0 y 2, 0, 1
;; z = 2, 0, 1 y 1, 2, 0

(define (determinante m)
  (let
      ;; Variables locales
      ((det 0)
      (x (extraer-columna m 0))
      (y (extraer-columna m 1))
      (z (extraer-columna m 2)))
      ;; Cuerpo de Let
      (do
          ;;Variables iterativas
          (
           (i 0 (+ i 1))
           )
         ;; Condición de parada
        ((= i 3) det)
        ;; Cuerpo del DO
        (set! det (+ det      ;; Se le suma al determinante
         (*(vector-ref x i)   ;; x_i donde i = i
           (vector-ref y (modulo (+ i 1) 3)) ;; y_i donde i = ((i+1)%3)
           (vector-ref z (modulo (+ i 2) 3)));; z_i donde i = ((i+2)%3)
         (- (* (vector-ref x i) ;; x_i donde i = i
           (vector-ref y (modulo (+ i 2) 3)) ;; y_i donde i = ((i+2)%3)
           (vector-ref z (modulo (+ i 1) 3)))))) ;; z_i donde i = ((i+1)%3)
       )
      )
 )
;(determinante #(#(1. 2. 3. ) #(4. 5. 6. ) #(7. 8. 9. )))
;(determinante #(#(1. 0 0 ) #(0 1 0 ) #(0 0 1 )))
;(determinante #(#(1 2 3 ) #(3 1 2 ) #(2 3 1 )))

#|
Resultados:
0.0
1.0
18
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 5. b.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

#|
Nombre:
   area-triangulo
Objetivo:
   Dados tres vertices, se obtiene el area de un triangulo
Parámetros:
 - x1: coordenada x del P1
 - y1: coordenada y del P1
 - x2: coordenada x del P2
 - y2: coordenada y del P2
 - x3: coordenada x del P3
 - y3: coordenada y del P3
Resultado:
   Numérico.
Descripción de la solucion:
   Dados los puntos P1(x1,y1), P2(x2,y2) y P3(x3,y3)
   El area viene dada por:
   
   área(P1, P2, P3) = valor_absoluto (
 
             |x1 y1 1|
       1/2 · |x2 y2 1|
             |x3 y3 1|
)

Funciones auxiliares a las que llama:
   determinante
|#

(define (area-triangulo x1 y1 x2 y2 x3 y3)
  (abs (* (/ 1 2)(determinante (vector (vector x1 y1 1)(vector x2 y2 1)(vector x3 y3 1)))))
  )
;(area-triangulo 0 0 0 4 5 0)
;(area-triangulo 7 2 9 4 5 2)

#|
Resultados:
10
2
|#

